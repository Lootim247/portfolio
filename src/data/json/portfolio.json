[
    {
        "id":"cs135",
        "title":"COMP 135: Machine Learning Coursework Projects",
        "div_struct": [
            {"type": "Title_Section", 
            "props": 
                {"text": "COMP 135: Machine Learning Coursework Projects", 
                "subtext": "Feature Engineering and Scikit-Learn Practice"}},
            {"type": "Paragraph_Section", "props": 
                {"text": ""}},
            {"type": "MultiPDF", "props": {"pdfs": [
                {"src":"/pdfs/cs135_p1.pdf", "title":"Project Report", "type":"pdf"}
            ]}}
        ]
    }, {
        "id":"cr_vision",
        "title":"Clash Royale Elixir Tracker",
        "div_struct": [
            {"type": "Title_Section", 
            "props": 
                {"text": "Clash Royale Elixir Tracker", 
                "subtext": "Data Pipelines and Pytorch Practice",
                "github": "https://github.com/Lootim247/CR_Vision"}},
            {"type": "Paragraph_Section", "props": 
                {"text": "This project aims to use computer vision to track a normally hidden resource. In Clash Royale, you place troops, spells, and towers to defend your own King Tower and attack your enemies. The resource used to place these towers is called elixir. It is generated at a steady rate and consumed when deploying troops. A core part of this game is that, at any given moment, you do not know the exact elixir count of your opponent. Instead, you infer the quantity based on the timing of their placements and the cost of each unit. \n\nAs a computer scientist, this mental calculation can be automated! Thus, I introduce the Clash Royale Elixir Tracker, a project designed to enhance my model training capabilities using PyTorch. The proposed program will take a series of images as input and output the current elixir range (the range of possible elixir values). The data will pass through an initial CNN model that identifies a general area where a troop was deployed. This area will then be processed and passed through a second CNN that outputs class predictions. Based on these predictions, the proposed elixir range will be updated. \n\nCurrently, the data pipeline has been initialized. Much of my work has focused on optimizing how to process video data efficiently, as this type of data is extremely memory-intensive. For training, I recorded and labeled gameplay, storing it as an MP4 file. You might assume that for training you could simply store all frames in a single large NumPy array, but I would strongly caution against itâ€”my own naive attempt turned a 3-minute video into 60GB. After experimenting with different approaches, such as seeking frames on demand, I found a nearly optimal storage method: I stored each frame individually but first heavily condensed it, reducing each video to roughly 2GB. \n\nI am excited to continue training and I will continue to post results!"}}
        ]
    }, {
        "id":"cs120",
        "title":"Web Programming",
        "div_struct": [
            {"type": "Title_Section", 
            "props": 
                {"text": "Web Programming", 
                "subtext": "My introduction to HTML, CSS, Javascript, PHP, SQL, NoSQL, and Node"}},
            {"type": "Paragraph_Section", "props": 
                {"text": "This class was a semester long graduate level class dabbling in -- you guessed it-- web development. \n\nProfessor Diorio spent a large amount of the class on HTML, Javascript, and CSS. I learned the basics of HTML by designing a simple about me page and adding CS (1). Later on we expanded this knowledge into a full band website featuring multiple pages! This theme continued with our next major project being a playable wordle game. This was a fun project that used an integrated dictionary API to check a persons input for its validity. Check it out and give it a try, its actually playable in the window (2)!"}},
            {"type": "MultiPDF", "props": {"pdfs": [
                {"src":"/code/wordle.txt", "title":"1. Wordle Sample Code", "type":"txt", "language": "HTML"},
                {"src":"/html/wordle.html", "title":"2. Playable Wordle", "type":"html"}
            ]}}
        ]
    }, {
        "id":"portfolio",
        "title":"The Designing of my Portfolio!",
        "div_struct": [
            {"type": "Title_Section", 
            "props": 
                {"text": "The Designing of my Portfolio!", 
                "subtext": "Practice Designing Simplistic Scalable Architecture",
                "github": "https://github.com/Lootim247/portfolio"}},
            {"type": "Paragraph_Section", "props": 
                {"text": "Welcome to my portfolio! This was designed using Next.js with Github used as a version management control. To get it up on the web I used vercel for deployment and linking with a GoDaddy domain.\n\nThis page was designed with the explicit constraint of simple and easy scalability. The backbone of this design methodology is the JSON file. Each and every page in this portfolio is generated with an editable JSON file. My resume is generated from a list of experiences, my front page is generated from a JSON containing paragraphs, and my portfolio structure is rendered entirely from a JSON. \n\nMy magnum opus in design is the individual portfolio page generation script. This very page that you are viewing is generated explicitly from a JSON, which enables me to choose the layout of components as well as the props that are passed within. As a portfolio is often accessed rather than inserted into, these pages are built statically on the server and served to the user as prerendeered pages for better performance. See the code samples below."}},
            {"type": "MultiPDF", "props": {"pdfs": [
                {"src":"/code/portfolio_ID.txt", "title":"1. Page Generation", "type":"txt", "language": "HTML"},
                {"src":"/code/portfolio_page_gen.txt", "title":"2. Generation JSON", "type":"txt", "language": "JSON"}
            ]}}
        ]
    }
]